####
# Dockerfile for Heroku Native Deployment with JDK
# ==================================================
# Multi-stage build: Extract JDK modules, then create runtime image
####

# Stage 1: Get JDK modules
FROM eclipse-temurin:21-jdk-alpine AS jdk-modules

# Extract only the compiler and base modules needed
RUN jlink \
    --add-modules java.base,java.compiler,jdk.compiler,jdk.zipfs \
    --strip-debug \
    --no-man-pages \
    --no-header-files \
    --compress=2 \
    --output /jdk-minimal

# Stage 2: Runtime image
FROM registry.access.redhat.com/ubi8/ubi-minimal:8.9

# Set working directory
WORKDIR /work/

# Install required libraries for JDK
RUN microdnf install -y glibc-langpack-en \
    && microdnf clean all

# Copy minimal JDK from stage 1
COPY --from=jdk-modules /jdk-minimal /opt/jdk

# Create non-root user and set permissions (Heroku requires user 1001)
RUN chown 1001:root /work \
    && chmod "g+rwX" /work

# Copy the native executable with proper permissions
COPY --chown=1001:root --chmod=0755 target/*-runner /work/application

# Set JAVA_HOME for compiler to find system classes
ENV JAVA_HOME=/opt/jdk
ENV PATH="${JAVA_HOME}/bin:${PATH}"

# Heroku dynamically assigns the PORT environment variable
ENV PORT=8080

# Switch to non-root user for security
USER 1001

# Expose the port (informational only, Heroku uses PORT env var)
EXPOSE ${PORT}

# Start the application with JAVA_HOME set for compiler
CMD exec ./application -Dquarkus.http.host=0.0.0.0 -Dquarkus.http.port=$PORT -Djava.home=/opt/jdk

